<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="title" content="Flappy Bird" />
    <meta name="description" content="Flappy Bird Game" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://theabbie.github.io/flappy" />
    <meta property="og:title" content="Flappy Bird" />
    <meta property="og:description" content="Flappy Bird Game" />
    <meta
      property="og:image"
      content="https://theabbie.github.io/blog/assets/sudoku.jpg"
    />
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://theabbie.github.io/flappy" />
    <meta property="twitter:title" content="Flappy Bird" />
    <meta property="twitter:description" content="Flappy Bird Game" />
    <meta
      property="twitter:image"
      content="https://theabbie.github.io/blog/assets/sudoku.jpg"
    />
    <style>
      @font-face {
        font-family: Gilroy;
        src: url("Gilroy.otf") format("opentype");
      }
      body {
        margin: 0;
        overflow-y: hidden;
        background-color: #121212;
      }
      * {
        box-sizing: border-box;
        font-family: Gilroy;
        user-select: none;
      }
      #world {
        background: linear-gradient(to bottom, #00000c 80%, #150800 100%);
      }
      #bird,
      .obstacle,
      #gameOver {
        fill: white;
        transform-box: fill-box;
        transform-origin: center;
        transition: transform 0.15s linear;
      }
      .obstacle {
        fill: url(#shine);
      }
      #gameOver {
        animation: pop 0.3s linear forwards;
      }
      @keyframes pop {
        from {
          transform: scale(0);
          opacity: 0;
        }
        to {
          transform: scale(1);
          opacity: 1;
        }
      }
    </style>
    <title>Flappy Bird</title>
  </head>
  <body>
    <svg id="world">
      <defs>
        <linearGradient id="shine" x1="0%" y1="0%" x2="100%" y2="0%">
          <stop offset="0%" style="stop-color: green; stop-opacity: 1" />
          <stop
            offset="100%"
            style="stop-color: greenyellow; stop-opacity: 1"
          />
        </linearGradient>
      </defs>
    </svg>
  </body>
  <script>
    const world = document.querySelector("#world");
    const windowWidth = "100%";
    const windowHeight = "100vh";
    world.setAttribute("width", windowWidth);
    world.setAttribute("height", windowHeight);
    const pillarHeight = window.innerHeight / 2;

    class position {
      constructor(id, x, y, width, height) {
        this.id = id;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
      }
    }

    class Flappy {
      constructor(width, height) {
        this.originFrame = null;
        this.lastFrame = null;
        this.width = width;
        this.height = height;
        this.bird = new position(
          "bird",
          this.width / 10,
          this.height / 2,
          Math.min(this.width / 5, 200),
          Math.min(this.height / 5, 80)
        );
        this.velocity = 0;
        this.jumpVelocity = -0.4;
        this.gravity = 0.0009;
        this.obstacles = [];
        this.jumped = false;
        this.over = false;
      }

      getGravity() {
        if (!this.jumped) return 0;
        return this.gravity;
      }

      getBird() {
        return this.bird;
      }

      getAngle() {
        const ang = parseInt(this.velocity * 90);
        if (ang < -45) return -45;
        if (ang > 30) return 30;
        return ang;
      }

      jump() {
        this.jumped = true;
        this.velocity = this.jumpVelocity;
      }

      hasJumped() {
        return this.jumped;
      }

      createObstacle() {
        let topHeight = Math.random() * this.height * 0.4;
        let bottomHeight = this.height * 0.6 - topHeight;
        if (Math.random() > 0.5)
          [topHeight, bottomHeight] = [bottomHeight, topHeight];
        this.obstacles.push(
          new position(
            `obs_top_${Date.now()}`,
            this.width,
            0,
            this.width / 10,
            topHeight
          )
        );
        this.obstacles.push(
          new position(
            `obs_bottom_${Date.now()}`,
            this.width,
            this.height - bottomHeight,
            this.width / 10,
            bottomHeight
          )
        );
      }

      getObstacles() {
        return this.obstacles;
      }

      isOver() {
        return this.over;
      }

      isCollison(obstacle) {
        let x = this.bird.x + this.bird.width / 2;
        let y = this.bird.y + this.bird.height / 2;
        if (
          x > obstacle.x &&
          x < obstacle.x + obstacle.width &&
          y > obstacle.y &&
          y < obstacle.y + obstacle.height
        ) {
          return true;
        }
        return false;
      }

      move(time) {
        let diff = 0;
        if (this.lastFrame != null) diff = time - this.lastFrame;
        if (this.originFrame == null) this.originFrame = time;
        this.lastFrame = time;
        this.velocity += this.getGravity() * diff;
        this.bird.y += this.velocity * diff;
        this.bird.y = Math.max(10, this.bird.y);
        this.bird.y = Math.min(this.height - 100, this.bird.y);
        if (this.jumped) {
          if (time - this.originFrame > 2500 || this.obstacles.length == 0) {
            this.originFrame = time;
            this.createObstacle();
          }
        }
        for (const obstacle of this.obstacles) {
          obstacle.x -= 0.4 * diff;
          if (this.isCollison(obstacle)) {
            this.over = true;
          }
        }
      }
    }

    class Graphics {
      static drawBird(birdpos, angle) {
        let bird = document.querySelector(`#${birdpos.id}`);
        if (!bird) {
          bird = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "image"
          );
          bird.setAttribute("href", "bird_alt.png");
          bird.setAttribute("id", birdpos.id);
          bird.setAttribute("width", birdpos.width);
          bird.setAttribute("height", birdpos.height);
          world.appendChild(bird);
        }
        bird.setAttribute("x", birdpos.x);
        bird.setAttribute("y", birdpos.y);
        bird.style.transform = `rotate(${angle}deg)`;
      }

      static drawObstacles(obstacles) {
        for (const obstaclepos of obstacles) {
          if (obstaclepos.x < -obstaclepos.width * 1.2) continue;
          let obstacle = document.querySelector(`#${obstaclepos.id}`);
          if (!obstacle) {
            obstacle = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "rect"
            );
            obstacle.setAttribute("id", obstaclepos.id);
            obstacle.setAttribute("class", "obstacle");
            obstacle.setAttribute("width", obstaclepos.width);
            obstacle.setAttribute("height", obstaclepos.height);
            world.appendChild(obstacle);
          }
          obstacle.setAttribute("x", obstaclepos.x);
          obstacle.setAttribute("y", obstaclepos.y);
        }
      }

      static showGameOver() {
        let gameOver = document.querySelector("#gameOver");
        if (!gameOver) {
          gameOver = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "image"
          );
          gameOver.setAttribute("id", "gameOver");
          world.appendChild(gameOver);
        }
        let gw = window.innerWidth / 4;
        let gh = window.innerHeight / 4;
        if (window.innerHeight > window.innerWidth) {
          gw = window.innerWidth * 0.8;
          gh = gw * 0.5;
        }
        gameOver.setAttribute("href", "game_over.png");
        gameOver.setAttribute("width", gw);
        gameOver.setAttribute("height", gh);
        gameOver.setAttribute("x", window.innerWidth / 2 - gw / 2);
        gameOver.setAttribute("y", window.innerHeight / 2 - gh / 2);
      }

      static showInstructions() {
        let instructions = document.querySelector("#instructions");
        if (!instructions) {
          instructions = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "image"
          );
          instructions.setAttribute("id", "instructions");
          world.appendChild(instructions);
        }
        let gw = window.innerWidth / 4;
        let gh = window.innerHeight / 4;
        if (window.innerHeight > window.innerWidth) {
          gw = window.innerWidth * 0.8;
          gh = gw * 0.5;
        }
        instructions.setAttribute("href", "instructions.png");
        instructions.setAttribute("width", gw);
        instructions.setAttribute("height", gh);
        instructions.setAttribute("x", window.innerWidth / 2 - gw / 2);
        instructions.setAttribute("y", window.innerHeight / 2 - gh / 2);
      }

      static hideGameOver() {
        let gameOver = document.querySelector("#gameOver");
        if (gameOver) gameOver.remove();
      }

      static hideInstructions() {
        let instructions = document.querySelector("#instructions");
        if (instructions) instructions.remove();
      }

      static reset(obstacles) {
        for (const obstaclepos of obstacles) {
          let obstacle = document.querySelector(`#${obstaclepos.id}`);
          if (obstacle) obstacle.remove();
        }
      }
    }

    class Input {
      static keys = {};

      static keyDown(e) {
        Input.keys[e.key] = true;
      }

      static keyUp(e) {
        Input.keys[e.key] = false;
      }

      static space() {
        return Input.keys[" "];
      }
    }

    function animate(time, game) {
      Graphics.drawBird(game.getBird(), game.getAngle());
      Graphics.drawObstacles(game.getObstacles());
      if (Input.space()) {
        game.jump();
        Graphics.hideInstructions();
      }
      game.move(time);
      if (!game.isOver()) requestAnimationFrame((t) => animate(t, game));
      else {
        Graphics.showGameOver();
        setTimeout(() => {
          Graphics.reset(game.getObstacles());
          Graphics.hideGameOver();
          initGame();
        }, 2000);
      }
    }

    function initGame() {
      const w = world.clientWidth;
      const h = window.innerHeight;
      const game = new Flappy(w, h);
      Input.keys = {};
      window.addEventListener("keydown", Input.keyDown);
      window.addEventListener("keyup", Input.keyUp);
      window.addEventListener("click", () => {
        game.jump();
        Graphics.hideInstructions();
      });
      Graphics.showInstructions();
      requestAnimationFrame((t) => animate(t, game));
    }

    window.onload = initGame;
  </script>
</html>
